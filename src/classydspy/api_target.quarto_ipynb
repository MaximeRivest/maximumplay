{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"ClassyDSPy: A Better DSPy API\"\n",
        "format: html\n",
        "execute:\n",
        "  echo: true\n",
        "  eval: true\n",
        "---\n",
        "\n",
        "\n",
        "## Overview\n",
        "\n",
        "This document explores an improved API design for DSPy that addresses key pain points:\n",
        "\n",
        "1. **No DSL for signatures** - Use Pydantic models instead of InputField/OutputField\n",
        "2. **No prompts in docstrings** - Separate prompt definition from code\n",
        "3. **Standard Python patterns** - Familiar APIs that don't require learning custom syntax\n",
        "\n",
        "## Core Design Philosophy\n",
        "\n",
        "The API should be built around:\n",
        "- **Input schema** (Pydantic model)\n",
        "- **Output schema** (Pydantic model) \n",
        "- **Input-target examples** (type-checked to match schemas)\n",
        "- **Prompt templates** (separate from code)\n",
        "\n",
        "## Basic Example: Person Extraction\n",
        "\n",
        "```{{python}}\n",
        "from pydantic import BaseModel\n",
        "import dspy\n",
        "\n",
        "class Person(BaseModel):\n",
        "    name: str\n",
        "    age: int\n",
        "    occupation: str\n",
        "\n",
        "person = dspy.Predict(input_format=str,\n",
        "                     output_format=Person,\n",
        "                     instructions=\"Extract:\",\n",
        "                     lm=dspy.LM(\"openai/gpt-4o-mini\"))\n",
        "\n",
        "print(person(\"John is a 30-year-old software engineer\"))\n",
        "# Person(name='John', age=30, occupation='software engineer')\n",
        "```\n",
        "\n",
        "## Advanced API: Compilation and Optimization\n"
      ],
      "id": "c11fcb33"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Example of how .compile and .save should work\n",
        "# with input/output schemas and training examples\n",
        "\n",
        "# Define schemas\n",
        "class PersonInput(BaseModel):\n",
        "    text: str\n",
        "    \n",
        "class PersonOutput(BaseModel):\n",
        "    name: str\n",
        "    age: int\n",
        "    occupation: str\n",
        "    confidence: float\n",
        "\n",
        "# Training examples (type-checked)\n",
        "examples = [\n",
        "    (PersonInput(text=\"Alice works as a doctor and is 35\"), \n",
        "     PersonOutput(name=\"Alice\", age=35, occupation=\"doctor\", confidence=0.95)),\n",
        "    # ... more examples\n",
        "]\n",
        "\n",
        "# Compile with optimization\n",
        "predictor = dspy.Predict(\n",
        "    input_schema=PersonInput,\n",
        "    output_schema=PersonOutput,\n",
        "    prompt_template=\"Extract person information from: {text}\"\n",
        ")\n",
        "\n",
        "# Optimize with examples\n",
        "optimized = predictor.compile(\n",
        "    examples=examples,\n",
        "    optimizer=dspy.BootstrapFewShot(),\n",
        "    evaluation_metric=\"accuracy\"\n",
        ")\n",
        "\n",
        "# Save for reuse\n",
        "optimized.save(\"person_extractor.json\")"
      ],
      "id": "d2e9c779",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Evaluation Dimensions\n",
        "\n",
        "For complex tasks, evaluation may need multiple dimensions:\n"
      ],
      "id": "0425bd7f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from typing import List\n",
        "\n",
        "class EvaluationDimension(BaseModel):\n",
        "    name: str\n",
        "    description: str\n",
        "    weight: float = 1.0\n",
        "\n",
        "class TaskOutput(BaseModel):\n",
        "    result: str\n",
        "    accuracy_score: float\n",
        "    creativity_score: float\n",
        "    coherence_score: float\n",
        "\n",
        "# Multi-dimensional evaluation\n",
        "evaluations = [\n",
        "    EvaluationDimension(\n",
        "        name=\"accuracy\", \n",
        "        description=\"Factual correctness of extracted information\",\n",
        "        weight=0.5\n",
        "    ),\n",
        "    EvaluationDimension(\n",
        "        name=\"creativity\", \n",
        "        description=\"Novel insights and connections made\",\n",
        "        weight=0.3\n",
        "    ),\n",
        "    EvaluationDimension(\n",
        "        name=\"coherence\", \n",
        "        description=\"Logical flow and consistency\",\n",
        "        weight=0.2\n",
        "    )\n",
        "]\n",
        "\n",
        "predictor = dspy.Predict(\n",
        "    input_schema=PersonInput,\n",
        "    output_schema=TaskOutput,\n",
        "    evaluation_dimensions=evaluations\n",
        ")"
      ],
      "id": "acb753f4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Fine-tuning and Reward Functions\n",
        "\n",
        "Beyond prompt optimization, the API should support:\n"
      ],
      "id": "a069f99e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Fine-tuning support\n",
        "fine_tuned = predictor.fine_tune(\n",
        "    examples=training_data,\n",
        "    base_model=\"openai/gpt-4o-mini\",\n",
        "    epochs=3,\n",
        "    learning_rate=1e-5\n",
        ")\n",
        "\n",
        "# Reward function optimization\n",
        "reward_optimized = predictor.optimize_with_reward(\n",
        "    reward_function=lambda input, output: calculate_reward(input, output),\n",
        "    rl_algorithm=\"ppo\",\n",
        "    iterations=1000\n",
        ")"
      ],
      "id": "26205150",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Benefits of This Approach\n",
        "\n",
        "1. **Type Safety**: Pydantic provides runtime type checking and IDE support\n",
        "2. **Familiar Patterns**: Standard Python class definitions instead of DSL\n",
        "3. **Separation of Concerns**: Prompts, schemas, and logic are clearly separated\n",
        "4. **Composability**: Easy to combine and extend components\n",
        "5. **Tooling Support**: Works with existing Python tooling (linters, formatters, etc.)"
      ],
      "id": "1f2bbc36"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "maximerivest-blog",
      "language": "python",
      "display_name": "Python (maximerivest-blog)",
      "path": "/home/maxime/.local/share/jupyter/kernels/maximerivest-blog"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}